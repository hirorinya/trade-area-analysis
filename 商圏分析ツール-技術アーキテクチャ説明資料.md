# å•†åœåˆ†æãƒ„ãƒ¼ãƒ« - æŠ€è¡“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£èª¬æ˜è³‡æ–™

---

# ğŸ—ï¸ å…¨ä½“åƒ

## ğŸ“¥ Input - ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã¨æ§‹é€ 

### **1. åœ°ç†ç©ºé–“ãƒ‡ãƒ¼ã‚¿**
```
Geographic Data Sources:
â”œâ”€â”€ Base Maps
â”‚   â”œâ”€â”€ Mapbox Vector Tiles (åœ°å›³è¡¨ç¤º)
â”‚   â”œâ”€â”€ OpenStreetMap ãƒ‡ãƒ¼ã‚¿ (é“è·¯ãƒ»å»ºç‰©)
â”‚   â””â”€â”€ è¡›æ˜Ÿç”»åƒãƒ‡ãƒ¼ã‚¿ (åœ°å½¢ãƒ»åœŸåœ°åˆ©ç”¨)
â”œâ”€â”€ Administrative Boundaries
â”‚   â”œâ”€â”€ éƒ½é“åºœçœŒå¢ƒç•Œãƒ‡ãƒ¼ã‚¿ (GeoJSON)
â”‚   â”œâ”€â”€ å¸‚åŒºç”ºæ‘å¢ƒç•Œãƒ‡ãƒ¼ã‚¿ (Shapefile)
â”‚   â””â”€â”€ ç”ºä¸ç›®å¢ƒç•Œãƒ‡ãƒ¼ã‚¿ (PostGIS geometry)
â””â”€â”€ Transportation Network
    â”œâ”€â”€ é“è·¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ (OSM + å•†ç”¨ãƒ‡ãƒ¼ã‚¿)
    â”œâ”€â”€ å…¬å…±äº¤é€šæ©Ÿé–¢è·¯ç·š (GTFS)
    â””â”€â”€ å¾’æ­©ãƒ«ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ (æ­©é“ãƒ»æ¨ªæ–­æ­©é“)
```

### **2. äººå£çµ±è¨ˆãƒ‡ãƒ¼ã‚¿**
```
Demographic Data Structure:
â”œâ”€â”€ Census Data (å›½å‹¢èª¿æŸ»)
â”‚   â”œâ”€â”€ population_by_age: {age_group, count, area_code}
â”‚   â”œâ”€â”€ household_income: {income_bracket, households, area_code}
â”‚   â”œâ”€â”€ family_structure: {type, count, area_code}
â”‚   â””â”€â”€ employment_status: {category, count, area_code}
â”œâ”€â”€ Real-time Demographics
â”‚   â”œâ”€â”€ mobile_location_data: {lat, lng, timestamp, demographic_id}
â”‚   â”œâ”€â”€ social_media_activity: {location, activity_type, timestamp}
â”‚   â””â”€â”€ consumer_behavior: {purchase_category, location, time}
â””â”€â”€ Economic Indicators
    â”œâ”€â”€ average_income: {area_code, median_income, year}
    â”œâ”€â”€ property_values: {lat, lng, price_per_sqm, date}
    â””â”€â”€ retail_sales: {category, sales_amount, area_code, period}
```

### **3. å•†æ¥­æ–½è¨­ãƒ»ç«¶åˆãƒ‡ãƒ¼ã‚¿**
```
Business Data Schema:
â”œâ”€â”€ POI (Points of Interest)
â”‚   â”œâ”€â”€ stores: {id, name, category, lat, lng, opening_hours}
â”‚   â”œâ”€â”€ restaurants: {id, cuisine_type, price_range, rating, capacity}
â”‚   â”œâ”€â”€ services: {id, service_type, target_demographic, hours}
â”‚   â””â”€â”€ competitors: {id, brand, size, market_share_estimate}
â”œâ”€â”€ Commercial Real Estate
â”‚   â”œâ”€â”€ available_properties: {lat, lng, size, rent, foot_traffic}
â”‚   â”œâ”€â”€ lease_rates: {area_code, property_type, rate_per_sqm}
â”‚   â””â”€â”€ zoning_data: {area_code, zoning_type, restrictions}
â””â”€â”€ Market Performance
    â”œâ”€â”€ sales_data: {store_id, monthly_sales, customer_count}
    â”œâ”€â”€ foot_traffic: {location, hourly_count, day_of_week}
    â””â”€â”€ seasonal_trends: {location, month, traffic_multiplier}
```

---

## âš™ï¸ Process - æ©Ÿèƒ½ã¨ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…

### **1. å•†åœå¢ƒç•Œç®—å‡ºã‚¨ãƒ³ã‚¸ãƒ³**

#### **Drive-time Isochrone Generation**
```typescript
// Mapbox Isochrone API + ã‚«ã‚¹ã‚¿ãƒ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
interface IsochroneRequest {
  center: [longitude, latitude];
  contours_minutes: [5, 10, 15, 30];
  profile: 'driving' | 'walking' | 'cycling';
}

// å®Ÿè£…ãƒ­ã‚¸ãƒƒã‚¯
class TradeAreaCalculator {
  async generateDriveTimeArea(location: Point, minutes: number[]): Promise<Polygon[]> {
    // 1. Mapbox Isochrone API å‘¼ã³å‡ºã—
    const response = await mapboxClient.getIsochrone({
      coordinates: location,
      contours_minutes: minutes,
      profile: 'driving'
    });
    
    // 2. é“è·¯æ¸‹æ»ãƒ‡ãƒ¼ã‚¿ã§è£œæ­£
    const adjustedPolygons = await this.adjustForTrafficPatterns(response.features);
    
    // 3. åœ°å½¢ãƒ»éšœå®³ç‰©ã«ã‚ˆã‚‹åˆ°é”å›°é›£ã‚¨ãƒªã‚¢é™¤å¤–
    return await this.removeInaccessibleAreas(adjustedPolygons);
  }
}
```

#### **äººå£é‡ã¿ä»˜ãå•†åœãƒ¢ãƒ‡ãƒ«**
```sql
-- PostGIS + ã‚«ã‚¹ã‚¿ãƒ SQLé–¢æ•°
CREATE OR REPLACE FUNCTION calculate_gravity_model(
  store_location GEOMETRY,
  competitor_locations GEOMETRY[],
  population_density NUMERIC[]
) RETURNS TABLE(area_id TEXT, attraction_probability NUMERIC) AS $$
BEGIN
  -- ãƒãƒ•ãƒ¢ãƒ‡ãƒ«ï¼ˆé‡åŠ›ãƒ¢ãƒ‡ãƒ«ï¼‰ã«ã‚ˆã‚‹å•†åœç¢ºç‡è¨ˆç®—
  RETURN QUERY
  SELECT 
    mesh.area_id,
    (store_attraction / total_attraction) as probability
  FROM (
    SELECT 
      m.area_id,
      (m.population * store_size) / POWER(ST_Distance(m.geom, store_location), 2) as store_attraction,
      SUM((competitor_sizes[i] * m.population) / POWER(ST_Distance(m.geom, competitor_locations[i]), 2)) as total_attraction
    FROM population_mesh m
    WHERE ST_DWithin(m.geom, store_location, 5000) -- 5kmåœå†…
  ) mesh;
END;
$$ LANGUAGE plpgsql;
```

### **2. ãƒ‡ãƒ¢ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯åˆ†æã‚¨ãƒ³ã‚¸ãƒ³**

#### **äººå£çµ±è¨ˆå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**
```python
# Python + Pandas + GeoPandas
class DemographicAnalyzer:
    def analyze_trade_area_demographics(self, trade_area_polygon, target_business_type):
        # 1. å•†åœå†…äººå£ãƒ¡ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
        population_data = self.extract_population_within_polygon(trade_area_polygon)
        
        # 2. æ¥­ç¨®åˆ¥ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé©åˆæ€§ã‚¹ã‚³ã‚¢ç®—å‡º
        target_score = self.calculate_target_compatibility(
            population_data, 
            BUSINESS_PROFILES[target_business_type]
        )
        
        # 3. æ¶ˆè²»åŠ›æŒ‡æ•°è¨ˆç®—
        purchasing_power = self.calculate_purchasing_power_index(
            population_data['income_distribution'],
            population_data['age_distribution']
        )
        
        return {
            'total_population': population_data['total'],
            'target_population': population_data['target_segment'],
            'purchasing_power_index': purchasing_power,
            'demographic_fit_score': target_score
        }
```

### **3. ç«¶åˆåˆ†æã‚¨ãƒ³ã‚¸ãƒ³**

#### **Market Share æ¨å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **
```javascript
// Node.js + Machine Learning
class CompetitorAnalyzer {
  async calculateMarketShare(location, competitors, businessType) {
    // 1. å„ç«¶åˆåº—ã®å•†åœé‡è¤‡åº¦è¨ˆç®—
    const overlapAnalysis = await this.calculateTradeAreaOverlap(location, competitors);
    
    // 2. åº—èˆ—è¦æ¨¡ãƒ»ãƒ–ãƒ©ãƒ³ãƒ‰åŠ›ã«ã‚ˆã‚‹é‡ã¿ä»˜ã‘
    const competitorWeights = competitors.map(comp => ({
      ...comp,
      weight: this.calculateCompetitorWeight(comp.brand_strength, comp.store_size, comp.years_operating)
    }));
    
    // 3. æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹å¸‚å ´ã‚·ã‚§ã‚¢äºˆæ¸¬
    const mlModel = await this.loadMarketShareModel(businessType);
    const predictedShare = await mlModel.predict({
      location_features: await this.extractLocationFeatures(location),
      competitor_features: competitorWeights,
      demographic_features: await this.getDemographicFeatures(location)
    });
    
    return {
      estimated_market_share: predictedShare,
      direct_competitors: overlapAnalysis.direct,
      indirect_competitors: overlapAnalysis.indirect,
      competitive_advantage_score: this.calculateAdvantageScore(location, competitors)
    };
  }
}
```

### **4. å£²ä¸Šäºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³**

#### **Revenue Projection Model**
```r
# R + Statistical Modeling
revenue_prediction_model <- function(location_data, demographic_data, competitor_data) {
  # 1. é‡å›å¸°åˆ†æã«ã‚ˆã‚‹åŸºç¤å£²ä¸Šäºˆæ¸¬
  base_model <- lm(
    monthly_revenue ~ 
      population_density + 
      avg_income + 
      foot_traffic + 
      competitor_distance + 
      accessibility_score,
    data = training_data
  )
  
  # 2. å­£ç¯€æ€§ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰èª¿æ•´
  seasonal_adjustment <- ts(
    historical_sales_data, 
    frequency = 12
  ) %>% decompose()
  
  # 3. ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®ã—ãŸäºˆæ¸¬åŒºé–“
  prediction_interval <- predict(
    base_model, 
    newdata = location_data, 
    interval = "prediction",
    level = 0.95
  )
  
  return(list(
    expected_revenue = prediction_interval[,"fit"],
    lower_bound = prediction_interval[,"lwr"],
    upper_bound = prediction_interval[,"upr"],
    confidence_level = 0.95
  ))
}
```

---

## ğŸ“¤ Output - åˆ†æçµæœå‡ºåŠ›

### **1. JSON API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ **
```json
{
  "analysis_id": "uuid-string",
  "location": {
    "latitude": 35.6762,
    "longitude": 139.6503,
    "address": "æ±äº¬éƒ½æ¸‹è°·åŒº...",
    "analysis_timestamp": "2024-01-15T10:30:00Z"
  },
  "trade_area": {
    "drive_time_polygons": {
      "5_minutes": {"type": "Polygon", "coordinates": [...]},
      "10_minutes": {"type": "Polygon", "coordinates": [...]},
      "15_minutes": {"type": "Polygon", "coordinates": [...]}
    },
    "walk_time_polygons": {
      "5_minutes": {"type": "Polygon", "coordinates": [...]},
      "10_minutes": {"type": "Polygon", "coordinates": [...]}
    }
  },
  "demographics": {
    "total_population": 45230,
    "age_distribution": {
      "20-29": 8920,
      "30-39": 12450,
      "40-49": 11230,
      "50-59": 8760,
      "60+": 3870
    },
    "income_distribution": {
      "low": 15680,
      "middle": 21450,
      "high": 8100
    },
    "household_types": {
      "single": 18900,
      "family": 20100,
      "elderly": 6230
    }
  },
  "market_analysis": {
    "competitors": [
      {
        "name": "ç«¶åˆåº—A",
        "distance_meters": 450,
        "estimated_market_share": 0.25,
        "competitive_threat_level": "high"
      }
    ],
    "market_saturation": 0.65,
    "opportunities": ["high_income_segment", "underserved_elderly"]
  },
  "financial_projections": {
    "monthly_revenue_estimate": {
      "conservative": 2800000,
      "realistic": 3500000,
      "optimistic": 4200000
    },
    "break_even_timeline": "8_months",
    "roi_projection": {
      "year_1": 0.15,
      "year_2": 0.28,
      "year_3": 0.42
    }
  }
}
```

### **2. PDF ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ**
```typescript
// Puppeteer + HTML Template
class ReportGenerator {
  async generatePDFReport(analysisData: AnalysisResult): Promise<Buffer> {
    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <link rel="stylesheet" href="report-styles.css">
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      </head>
      <body>
        <!-- Executive Summary -->
        <section class="executive-summary">
          <h1>å•†åœåˆ†æãƒ¬ãƒãƒ¼ãƒˆ</h1>
          <div class="key-metrics">
            <div class="metric">
              <h3>äºˆæƒ³æœˆå£²ä¸Š</h3>
              <p class="value">Â¥{{formatCurrency(analysisData.revenue_estimate)}}</p>
            </div>
            <div class="metric">
              <h3>å•†åœäººå£</h3>
              <p class="value">{{analysisData.demographics.total_population}}äºº</p>
            </div>
          </div>
        </section>
        
        <!-- Interactive Maps -->
        <section class="maps">
          <div id="trade-area-map"></div>
          <div id="demographic-heatmap"></div>
        </section>
        
        <!-- Charts and Graphs -->
        <section class="analytics">
          <canvas id="demographic-chart"></canvas>
          <canvas id="revenue-projection-chart"></canvas>
        </section>
      </body>
      </html>
    `;
    
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.setContent(htmlTemplate);
    const pdf = await page.pdf({ format: 'A4' });
    await browser.close();
    
    return pdf;
  }
}
```

---

# ğŸœ ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

## ãƒ©ãƒ¼ãƒ¡ãƒ³å±‹ã®å ´åˆ

### **åˆ†æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š**
```json
{
  "business_type": "ramen_restaurant",
  "target_demographics": {
    "primary": ["male_20_40", "office_workers", "students"],
    "secondary": ["family_with_children", "tourists"]
  },
  "operating_hours": "11:00-23:00",
  "peak_hours": ["12:00-14:00", "19:00-21:00"],
  "catchment_method": "walk_time",
  "max_walk_minutes": 10
}
```

### **ç‰¹åŒ–åˆ†æãƒ­ã‚¸ãƒƒã‚¯**
```python
class RamenShopAnalyzer(TradeAreaAnalyzer):
    def analyze_ramen_market(self, location):
        # 1. ãƒ©ãƒ³ãƒã‚¿ã‚¤ãƒ äººå£ï¼ˆã‚ªãƒ•ã‚£ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ï¼‰åˆ†æ
        lunch_population = self.calculate_daytime_population(
            location, 
            time_range="12:00-14:00",
            demographic_filter=["office_workers", "students"]
        )
        
        # 2. å¤œé–“äººå£ï¼ˆå±…ä½è€…ãƒ»å¸°å®…é€”ä¸­ï¼‰åˆ†æ  
        dinner_population = self.calculate_evening_population(
            location,
            time_range="19:00-21:00", 
            demographic_filter=["residents", "commuters"]
        )
        
        # 3. ãƒ©ãƒ¼ãƒ¡ãƒ³åº—ç‰¹æœ‰ã®ç«¶åˆåˆ†æ
        ramen_competitors = self.find_competitors(
            location,
            categories=["ramen", "fast_food", "asian_restaurant"],
            radius_meters=500
        )
        
        # 4. ç«‹åœ°é©æ€§ã‚¹ã‚³ã‚¢ï¼ˆãƒ©ãƒ¼ãƒ¡ãƒ³åº—ç‰¹åŒ–ï¼‰
        location_score = self.calculate_ramen_location_score({
            'visibility': self.assess_street_visibility(location),
            'foot_traffic': lunch_population + dinner_population,
            'parking_availability': self.check_parking_nearby(location),
            'public_transport': self.assess_transit_accessibility(location),
            'late_night_safety': self.assess_area_safety(location, "night")
        })
        
        return {
            'lunch_market_size': lunch_population,
            'dinner_market_size': dinner_population,
            'daily_customer_potential': lunch_population * 0.15 + dinner_population * 0.25,
            'expected_daily_revenue': self.calculate_ramen_revenue(lunch_population, dinner_population),
            'competitor_density': len(ramen_competitors),
            'location_suitability_score': location_score
        }
```

### **å‡ºåŠ›ä¾‹**
```json
{
  "business_type": "ramen_restaurant",
  "location_analysis": {
    "address": "æ±äº¬éƒ½æ–°å®¿åŒºè¥¿æ–°å®¿1-1-1",
    "suitability_score": 8.2,
    "key_strengths": [
      "ã‚ªãƒ•ã‚£ã‚¹è¡—ã§å¹³æ—¥ãƒ©ãƒ³ãƒéœ€è¦é«˜",
      "é§…å¾’æ­©3åˆ†ã®å¥½ç«‹åœ°",
      "æ·±å¤œå–¶æ¥­å¯èƒ½ã‚¨ãƒªã‚¢"
    ]
  },
  "market_size": {
    "lunch_time_population": 12500,
    "dinner_time_population": 8900,
    "potential_daily_customers": 4100,
    "market_penetration_rate": 0.18
  },
  "revenue_projection": {
    "daily_revenue": {
      "lunch": 380000,
      "dinner": 290000,
      "total": 670000
    },
    "monthly_revenue": 18900000,
    "annual_revenue": 226800000
  },
  "competitive_landscape": {
    "direct_competitors": 3,
    "market_share_available": 0.35,
    "differentiation_opportunities": [
      "è±šéª¨ä»¥å¤–ã®ç‰¹åŒ–ã‚¹ãƒ¼ãƒ—",
      "å¥åº·å¿—å‘ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
      "ãƒ†ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆå¯¾å¿œå¼·åŒ–"
    ]
  }
}
```

---

## â›½ ã‚¬ã‚¹ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®å ´åˆ

### **åˆ†æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š**
```json
{
  "business_type": "gas_station",
  "target_demographics": {
    "primary": ["car_owners", "delivery_drivers", "taxi_drivers"],
    "secondary": ["truck_drivers", "tourists"]
  },
  "operating_hours": "24_hours",
  "catchment_method": "drive_time",
  "max_drive_minutes": 5,
  "additional_services": ["convenience_store", "car_wash", "maintenance"]
}
```

### **ç‰¹åŒ–åˆ†æãƒ­ã‚¸ãƒƒã‚¯**
```python
class GasStationAnalyzer(TradeAreaAnalyzer):
    def analyze_gas_station_market(self, location):
        # 1. äº¤é€šé‡åˆ†æï¼ˆ24æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        traffic_analysis = self.analyze_traffic_patterns(
            location,
            radius_meters=2000,
            time_granularity="hourly"
        )
        
        # 2. è»Šä¸¡ç™»éŒ²ãƒ‡ãƒ¼ã‚¿åˆ†æ
        vehicle_data = self.analyze_vehicle_registration(
            location,
            vehicle_types=["passenger_car", "light_truck", "motorcycle"]
        )
        
        # 3. é€šå‹¤ãƒ«ãƒ¼ãƒˆåˆ†æ
        commute_patterns = self.analyze_commute_routes(
            location,
            peak_hours=["07:00-09:00", "17:00-19:00"]
        )
        
        # 4. æ—¢å­˜ã‚¬ã‚¹ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç«¶åˆåˆ†æ
        gas_station_competitors = self.find_competitors(
            location,
            categories=["gas_station", "charging_station"],
            radius_meters=3000
        )
        
        # 5. ç‡ƒæ–™éœ€è¦äºˆæ¸¬
        fuel_demand = self.calculate_fuel_demand({
            'daily_traffic': traffic_analysis['average_daily_traffic'],
            'vehicle_efficiency': self.get_average_fuel_efficiency(),
            'trip_distance': commute_patterns['average_trip_distance'],
            'market_share_estimate': 0.15  # æ–°è¦å‚å…¥æƒ³å®š
        })
        
        return {
            'daily_traffic_volume': traffic_analysis['average_daily_traffic'],
            'peak_hour_traffic': traffic_analysis['peak_hour_volume'],
            'potential_daily_customers': fuel_demand['daily_customers'],
            'fuel_sales_volume': fuel_demand['daily_liters'],
            'convenience_store_potential': self.assess_convenience_store_demand(location),
            'competitive_advantage': self.assess_gas_station_advantages(location, gas_station_competitors)
        }
```

### **å‡ºåŠ›ä¾‹**
```json
{
  "business_type": "gas_station",
  "location_analysis": {
    "address": "åƒè‘‰çœŒæµ¦å®‰å¸‚èˆæµœ1-1",
    "suitability_score": 9.1,
    "key_strengths": [
      "ä¸»è¦å¹¹ç·šé“è·¯æ²¿ã„",
      "é€šå‹¤ãƒ«ãƒ¼ãƒˆä¸Šã®å¥½ç«‹åœ°",
      "ç«¶åˆåº—èˆ—ã¾ã§è·é›¢ã‚ã‚Š"
    ]
  },
  "traffic_analysis": {
    "average_daily_traffic": 28500,
    "peak_hour_volume": 2100,
    "commuter_ratio": 0.68,
    "commercial_vehicle_ratio": 0.22
  },
  "fuel_demand_projection": {
    "daily_fuel_sales": {
      "gasoline": 15400,
      "diesel": 3200,
      "total_liters": 18600
    },
    "daily_customers": 850,
    "average_fill_volume": 21.9
  },
  "revenue_projection": {
    "fuel_sales_monthly": 28900000,
    "convenience_store_monthly": 4200000,
    "car_wash_monthly": 1800000,
    "total_monthly_revenue": 34900000,
    "annual_revenue": 418800000
  },
  "competitive_analysis": {
    "nearest_competitor_distance": 2.8,
    "market_share_potential": 0.42,
    "pricing_advantage_opportunity": 0.05,
    "service_differentiation": [
      "EVå……é›»ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ä½µè¨­",
      "24æ™‚é–“ã‚³ãƒ³ãƒ“ãƒ‹",
      "é«˜å“è³ªæ´—è»Šã‚µãƒ¼ãƒ“ã‚¹"
    ]
  },
  "risk_factors": {
    "ev_transition_impact": "medium",
    "fuel_price_volatility": "high", 
    "environmental_regulations": "medium"
  }
}
```

---

## ğŸ”§ ã‚·ã‚¹ãƒ†ãƒ é€£æºãƒ»APIä»•æ§˜

### **External API Dependencies**
```yaml
mapbox_apis:
  - isochrone_api: "å•†åœå¢ƒç•Œç”Ÿæˆ"
  - geocoding_api: "ä½æ‰€ãƒ»åº§æ¨™å¤‰æ›"
  - directions_api: "ãƒ«ãƒ¼ãƒˆæœ€é©åŒ–"
  - static_images_api: "åœ°å›³ç”»åƒç”Ÿæˆ"

government_data_apis:
  - e_stat_api: "æ”¿åºœçµ±è¨ˆãƒ‡ãƒ¼ã‚¿"
  - census_api: "å›½å‹¢èª¿æŸ»ãƒ‡ãƒ¼ã‚¿"
  - economic_census_api: "äº‹æ¥­æ‰€ãƒ‡ãƒ¼ã‚¿"

commercial_data_apis:
  - foursquare_api: "POIãƒ‡ãƒ¼ã‚¿"
  - google_places_api: "åº—èˆ—æƒ…å ±"
  - yelp_api: "ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»è©•ä¾¡ãƒ‡ãƒ¼ã‚¿"
```

### **Internal Microservices Architecture**
```
Frontend React App
       â†“
   API Gateway
   â”œâ”€â”€ Authentication Service
   â”œâ”€â”€ Trade Area Service â†’ PostGIS Database
   â”‚                    â†’ Mapbox API
   â”œâ”€â”€ Demographics Service â†’ Demographics DB
   â”‚                       â†’ Government APIs  
   â”œâ”€â”€ Competitor Analysis Service â†’ Business Data DB
   â”‚                               â†’ Commercial APIs
   â””â”€â”€ Revenue Prediction Service â†’ ML Model Service
```

ã“ã®æŠ€è¡“ä»•æ§˜æ›¸ã«ã‚ˆã‚Šã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å†…éƒ¨å‹•ä½œã¨å…·ä½“çš„ãªæ¥­ç¨®åˆ¥æ´»ç”¨æ–¹æ³•ãŒæ˜ç¢ºã«ãªã‚Šã¾ã™ã€‚ 